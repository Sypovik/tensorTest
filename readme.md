## Инструкция по запуску задач

  

### Общие требования

  

Перед запуском убедитесь, что у вас установлены:

  

- **Python* 3.6* или новее

- **Git** (для задачи 2)

- **Bash** (для задачи 4)

- **Multipass** (для задачи 4, если используется виртуальная машина)

  

### Задача 1: Клиент синхронизации времени

  

Получение текущего времени с сервера Яндекс.Времени.

  

**Запуск**:

```bash

python3 task1.py

```

**Особенности**:


- Выполняет 5 параллельных запросов к API

- Автоматически определяет временную зону для Москвы (`geo_id=213`)

- Выводит сырые данные, человеко-читаемое время и временную дельту


**Пример вывода**:

```bash
...

Результат запроса #5

Сырой ответ:

{"time":1750266504157,"clocks":{"213":{"id":213,"name":"Moscow","offset":10800000,"offsetString":"UTC+3:00","showSunriseSunset":true,"sunrise":"03:44","sunset":"21:17","isNight":false,"skyColor":"#e79f73","weather":{"temp":17,"icon":"bkn-d","link":"https://yandex.ru/pogoda/213?lat=55.755863&lon=37.6177"},"parents":[{"id":225,"name":"Russia"}]},"isSensetiveRegion":false}}

  

Время и временная зона:

2025-06-18 20:08:24 UTC+3:00

Дельта времени: 0.431401 сек

----------------

  

Средняя дельта по 5 запросам: 0.344342 сек

Общее время выполнения: 0.47 сек  

```

### Задача 2: Система сборки проектов

Клонирование репозитория и создание версионного архива.

  

**Запуск** (пример для hello-kubernetes):

  
  

```bash

python3 task2.py \

--repo-url https://github.com/paulbouwer/hello-kubernetes \

--src-path src/app \

--version 25.3000

  

```

**Параметры**:

  

- `--repo-url`: URL Git-репозитория (обязательный)

- `--src-path`: Путь к исходникам в репозитории (обязательный)

- `--version`: Версия продукта (обязательный)

  

**Что делает скрипт**:


1. Клонирует репозиторий (с глубиной 1 для экономии времени)

2. Копирует указанную директорию с исходниками

3. Создает version.json с метаданными

4. Формирует zip-архив с именем вида **"app28032023.zip"**

  

**Пример вывода**:

```bash

Конфигурация сборки:

URL репозитория: https://github.com/paulbouwer/hello-kubernetes

Путь к исходникам: src/app/

Версия: 25.3000

Рабочая директория: tmp/

Имя архива: app19062025

Путь к архиву: ./

  

Начало процесса сборки...

Репозиторий успешно склонирован в tmp/clone

Исходные файлы скопированы в tmp/src/app

Файл версии создан: tmp/src/app/version.json

Временная директория tmp/clone с репозиторием удалена

Архив создан: ./app19062025.zip

Сборка успешно завершена!

```

### Задача 3: Анализатор версий ПО

Сравнение версий ПО на основе шаблонов.

**Запуск**:
```bash

python3 task3.py --version 3.1.0 --config ./config.json

```

**Параметры**:

- `--version`: Целевая версия для сравнения (обязательный)

- `--config`: Путь к файлу конфигурации (по умолчанию ./config.json)


**Формат config.json**:

``` json
{
"Sh1": "3.*.2",
"Sh2": "3.*.1",
"Sh3": "1.2.3.*"
}

```

**Пример вывода**:


```bash

Анализатор версий:

Целевая версия: 3.1.0

Шаблонов загружено: 3

Вариантов сгенерировано: 6


Все версии (отсортировано):
1.2.3.0
1.2.3.1
3.0.1
3.0.2
3.1.1
3.1.2

Версии старше 3.1.0:
1.2.3.0
1.2.3.1
3.0.1
3.0.2

```

  

### Задача 4: Миграция systemd-демонов

  

**Описание**: Перенос демонов между директориями с обновлением конфигурации.


**Запуск через виртуальную машину**:


1. Создаем и настраиваем ВМ:
```bash

make create

```

Если с расшариванием папок:
```bash

make create target=mount

```
2. Подключаемся к ВМ:

```bash

make bash

```

3. Внутри ВМ выполняем:
```bash

sudo ./script.sh

```

**Альтернативный запуск (без VM)**:

  
```bash

sudo ./task4/src_shared_vm/script.sh

```

**Что делает скрипт**:

  

1. Создает бэкапы текущей конфигурации

2. Останавливает сервисы

3. Перемещает файлы демонов из `/opt/misc `в `/srv/data`

4. Обновляет пути в unit-файлах

5. Запускает сервисы с новой конфигурацией

6. Проверяет успешность запуска через `log.txt`

  

```bash

...

[00:32:07] [INFO] Обработка сервиса: foobar-gamma.service

[00:32:07] [INFO] Останавливаем сервис foobar-gamma.service

[00:32:07] [OK] Сервис foobar-gamma.service остановлен

[00:32:07] [INFO] Копирование: /opt/misc/gamma → /srv/data/

[00:32:07] [INFO] Обновляем пути в unit-файле /etc/systemd/system/foobar-gamma.service

[00:32:07] [INFO] Перезагрузка systemd daemon

[00:32:08] [INFO] Запускаем сервис foobar-gamma.service

[00:32:08] [OK] Сервис foobar-gamma.service запущен

[00:32:08] [OK] foobar-gamma.service — завершено

[00:32:08] ------------------------

[00:32:08] [OK] Файлы log.txt найден — демоны запущены.

[00:32:08] [INFO] /srv/data/beta/log.txt : start beta

[00:32:08] [INFO] /srv/data/alpha/log.txt : start alpha

[00:32:08] [INFO] /srv/data/gamma/log.txt : start gamma

```

  
  

**Примечание**: Если скрипт находится в директории Документы (и используется snap-версия `multipass`), рекомендуется переместить проект в другую директорию (например, `~/projects`)

## Описание решений

  

### Задача 1: Клиент синхронизации времени

  

Реализация класса `TimeSyncClient` позволила эффективно организовать работу с API времени. Использование объектно-ориентированного подхода было обусловлено необходимостью сохранять состояние между вызовами и инкапсулировать логику обработки временных данных. Класс объединяет все этапы работы: выполнение HTTP-запросов, парсинг JSON-ответов, преобразование временных меток и параллельное выполнение операций.

  

Разделение логики на отдельные методы (`fetch_raw_data`, `parse_response`, `calculate_human_time`) значительно улучшило читаемость и поддерживаемость кода. Особенно важно отметить преимущество параллельных запросов - при тестировании 5 параллельных запросов выполняются со скорость 1.5 последовательных запросов.

### Задача 2: Система сборки проектов

  

Класс `BuildScript` реализует полноценный конвейер сборки. Основное преимущество - возможность сохранять состояние сборки между этапами и инкапсулировать сложные операции. Например, параметры вроде repo_url используются на нескольких этапах процесса, и их хранение в объекте исключает необходимость постоянной передачи между функциями.

  

### Задача 3: Анализатор версий ПО

  

Класс `VersionAnalyzer` решает нетривиальную задачу сравнения версий программного обеспечения. Объектно-ориентированный подход здесь особенно ценен, так как позволяет хранить состояние анализа (целевую версию, шаблоны, сгенерированные варианты) и инкапсулировать логику нормализации версий.

  

Алгоритм преобразования версий в кортежи фиксированной длины (например, 1.2.3 → (1, 2, 3, 0, 0)) обеспечивает корректное сравнение даже при разном количестве компонентов. Это особенно важно при работе с шаблонами версий (1._, 2.3._), где звездочка может означать любое число.

  

### Задача 4: Миграция systemd-демонов

  

Этот скрипт представляет собой комплексное решение для переноса systemd-демонов между директориями. Каждая операция (остановка сервиса, перемещение файлов, обновление конфигурации) выделена в отдельную функцию, что значительно улучшает читаемость и упрощает отладку.

  

Особое внимание уделено безопасности операций:

  

- Автоматические бэкапы с timestamp позволяют восстановить систему в случае ошибки

- Проверка прав доступа гарантирует, что скрипт выполняется с необходимыми привилегиями

- Валидация каждого этапа предотвращает частичное выполнение операций

- Контроль через анализ `log.txt` обеспечивает проверку успешности запуска демонов

  

#### Работа с виртуальной машиной

  

Для тестирования скрипта используется виртуальная машина, управляемая через Makefile. Процесс работы включает несколько этапов:

  

1. Создание ВМ: `make create`

2. Подключение: `make bash`

3. Запуск скрипта: `sudo ./script.sh`

  

Изначально возникли сложности с расшариванием папок при расположении проекта в Документах (из-за ограничений `snap`). Решением стало:

  

- Размещение проекта вне ограниченных директорий

- Использование прямого копирования файлов вместо расшаривания

  

Папки `deamons_shared_vm` и `src_shared_vm` специально организованы как общие, чтобы можно было отслеживать изменения как на хосте, так и в виртуальной машине. Главный исполняемый файл `script.sh `размещен в `src_shared_vm` вместе с `logger.sh`, что обеспечивает удобное логирование операций.

  

## Возможные улучшения

  

В будущем реализацию можно улучшить несколькими способами. Добавление unit-тестов повысит надежность кода, особенно для сложных операций сравнения версий или обработки временных данных. Механизм отката изменений сделает систему более устойчивой к ошибкам во время выполнения. Поддержка конфигурационных файлов упростит настройку без изменения кода. Расширенное логирование с ротацией файлов поможет в диагностике проблем. Интеграция с CI/CD системами позволит автоматизировать процесс тестирования и развертывания.

  

Для задачи с демонами можно реализовать dry-run режим для предварительной проверки изменений, а также добавить более детализированное логирование каждого этапа миграции. Улучшение обработки ошибок сделает скрипт более устойчивым к нестандартным ситуациям.